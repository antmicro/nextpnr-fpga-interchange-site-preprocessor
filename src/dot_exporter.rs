/* Copyright (C) 2022 Antmicro
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     https://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

use std::collections::HashMap;
use std::borrow::Borrow;
use crate::ic_loader::archdef::Root as Device;
use crate::common::IcStr;
use crate::router::{PinDir, BELInfo};
use crate::router::site_brute_router::{
    RoutingGraph,
    RoutingGraphNodeKind
};

pub struct SiteRoutingGraphDotExporter<'d, G, B, P, T> where 
    G: Borrow<RoutingGraph>,
    B: Borrow<Vec<BELInfo>>,
    P: Borrow<Vec<(usize, usize)>>,
    T: Borrow<crate::ic_loader::archdef::TileTypeReader<'d>>
{
    graph: G,
    bels: B,
    tile_belpin_idx_to_bel_pin: P,
    tt: T,
    _d: std::marker::PhantomData<&'d ()>,
}

impl<'d, G, B, P, T> SiteRoutingGraphDotExporter<'d, G, B, P, T> where 
    G: Borrow<RoutingGraph>,
    B: Borrow<Vec<BELInfo>>,
    P: Borrow<Vec<(usize, usize)>>,
    T: Borrow<crate::ic_loader::archdef::TileTypeReader<'d>>
{
    pub fn new(graph: G, bels: B, tile_belpin_idx_to_bel_pin: P, tt: T) -> Self {
        Self { graph, bels, tile_belpin_idx_to_bel_pin, tt, _d: Default::default() }
    }

    pub fn export_dot(&self, device: &Device<'d>, name: &str) -> String {
        let mut bel_subgraphs = HashMap::new();
    
        /* Group pins of the same BELs into subgraphs */
        let st_list = device.reborrow().get_site_type_list().unwrap();
        for node_idx in 0 .. self.graph.borrow().node_count() {
            let node = self.graph.borrow().get_node(node_idx);
            let (bel_idx, bel_is_routing, bel_is_site_port) = match node.kind {
                RoutingGraphNodeKind::BelPort(bel_idx) => (bel_idx, false, false),
                RoutingGraphNodeKind::RoutingBelPort(bel_idx) => (bel_idx, true, false),
                RoutingGraphNodeKind::SitePort(bel_idx) => (bel_idx, true, true),
                RoutingGraphNodeKind::FreePort => unreachable!(),
            };
            let stitt = self.bels.borrow()[bel_idx].site_type_idx;
            let bel_name = device.ic_str(self.bels.borrow()[bel_idx].name).unwrap();
            let st_idx =
                self.tt.borrow().get_site_types().unwrap().get(stitt).get_primary_type();
            let st = st_list.get(st_idx);
            let st_name = device.ic_str(st.get_name()).unwrap();
    
            let bel_name = format!("{}_{}/{}", st_name, stitt, bel_name);
    
            let bucket = bel_subgraphs.entry(bel_name)
                .or_insert_with(|| BELSubGraph::default());
            
            if bel_is_site_port {
                bucket.bel_category = BELSubGrapgBELCategory::SitePort;
            } else if bel_is_routing {
                bucket.bel_category = BELSubGrapgBELCategory::Routing;
            }
    
            bucket.pins.push(node_idx);
        }
        
        /* Write DOT */
        let mut dot = "# DOT Graph generated by NISP\n\n".to_string();
        dot += &format!("digraph {} {{\n\n", name);
    
        for (bel_name, bel_subgraph) in bel_subgraphs {
            
    
            dot += &format!("    subgraph cluster_{} {{\n", bel_name.replace('/', "__"));
            dot += &format!("        node [style=filled];\n");
            dot += &format!("        label = \"{}\";\n", bel_name);
            dot += &format!(
                "        color = \"{}\";\n",
                bel_subgraph.bel_category.get_color_str()
            );
    
            for pin_idx in &bel_subgraph.pins {
                let (bel_idx, bel_pin_idx) =
                    self.tile_belpin_idx_to_bel_pin.borrow()[*pin_idx];
                let bel = &self.bels.borrow()[bel_idx];
                
                let pin_name = device.ic_str(bel.pins[bel_pin_idx].name).unwrap();
                
                dot += &format!(
                    "        {} [label=\"{}\", color={}];\n",
                    pin_idx,
                    pin_name,
                    match self.graph.borrow().get_node(*pin_idx).dir {
                        PinDir::Input => "\"#8ed38e\"",
                        PinDir::Output => "\"#7cc1c4\"",
                        PinDir::Inout => "\"#ffcf2f\""
                    }
                );
            }
            dot += &format!("    }}\n\n");
        }
    
        for from in 0 .. self.graph.borrow().node_count() {
            for to in self.graph.borrow().edges_from(from) {
                dot += &format!("    {} -> {};\n", from, to);
            }
        }
    
        dot += "}\n";
    
        dot
    }
}

enum BELSubGrapgBELCategory {
    NoRouting,
    Routing,
    SitePort,
}

impl BELSubGrapgBELCategory {
    fn get_color_str(&self) -> &'static str {
        match self {
            Self::NoRouting => "blue",
            Self::Routing => "purple",
            Self::SitePort => "green"
        }
    }
}

struct BELSubGraph {
    bel_category: BELSubGrapgBELCategory,
    pins: Vec<usize>,
}

impl Default for BELSubGraph {
    fn default() -> Self {
        Self {
            bel_category: BELSubGrapgBELCategory::NoRouting,
            pins: Vec::new(),
        }
    }
}
